<!DOCTYPE html>
<html><head lang="ja">
	<meta charset="utf-8" />
	<meta http-equiv="X-UA-Compatible" content="IE=edge"><title>Spring Bootで コンポーネント外からコンポーネントを取得したかった - 発火後忘失</title><meta name="viewport" content="width=device-width, initial-scale=1">
	<meta name="description" content="動機
CDI で言うところの CDI.current().getBeans(...) とか CDI.current().select(...)とかそんな感じのことをやりたかった。
参考リファレンス
ドキュメントでは、やりたいことが書いてあるように見えたのはこのセクション" />
	<meta property="og:image" content=""/>
	<meta property="og:url" content="https://yukihane.github.io/blog/201906/01/spring-boot-component-out-of-container/">
  <meta property="og:site_name" content="発火後忘失">
  <meta property="og:title" content="Spring Bootで コンポーネント外からコンポーネントを取得したかった">
  <meta property="og:description" content="動機 CDI で言うところの CDI.current().getBeans(...) とか CDI.current().select(...)とかそんな感じのことをやりたかった。
参考リファレンス ドキュメントでは、やりたいことが書いてあるように見えたのはこのセクション">
  <meta property="og:locale" content="ja">
  <meta property="og:type" content="article">
    <meta property="article:section" content="blog">
    <meta property="article:published_time" content="2019-06-01T20:15:54+00:00">
    <meta property="article:modified_time" content="2019-06-01T20:15:54+00:00">
    <meta property="article:tag" content="Spring-Boot">

  <meta name="twitter:card" content="summary">
  <meta name="twitter:title" content="Spring Bootで コンポーネント外からコンポーネントを取得したかった">
  <meta name="twitter:description" content="動機 CDI で言うところの CDI.current().getBeans(...) とか CDI.current().select(...)とかそんな感じのことをやりたかった。
参考リファレンス ドキュメントでは、やりたいことが書いてあるように見えたのはこのセクション">

        <link href="https://yukihane.github.io/css/fonts.2c2227b81b1970a03e760aa2e6121cd01f87c88586803cbb282aa224720a765f.css" rel="stylesheet">
	

	
	<link rel="stylesheet" type="text/css" media="screen" href="https://yukihane.github.io/css/main.6a0f23ea50fd34b46fee262a5a68e17d458c51a2bc99ba1ba018065de6b180c3.css" />
</head>
<body>
        <div class="content"><header>
	<div class="main">
		<a href="https://yukihane.github.io/">発火後忘失</a>
	</div>
	<nav>
		
		<a href="blog">Blog</a>
		
		<a href="docs">Docs</a>
		
		
	</nav>
</header>

<main>
  <article>
    <div class="post-container">
      
      <div class="post-content">
        <div class="title">
          <h1 class="title">Spring Bootで コンポーネント外からコンポーネントを取得したかった</h1>
          <div class="meta">Posted on 2019/06/01</div>
        </div>
        
        <section class="body">
          <h1 id="動機">動機</h1>
<p>CDI で言うところの <code>CDI.current().getBeans(...)</code> とか <code>CDI.current().select(...)</code>とかそんな感じのことをやりたかった。</p>
<h1 id="参考リファレンス">参考リファレンス</h1>
<p>ドキュメントでは、やりたいことが書いてあるように見えたのはこのセクション</p>
<ul>
<li><a href="https://docs.spring.io/spring/docs/5.1.7.RELEASE/spring-framework-reference/core.html#aop-atconfigurable">5.10.1. Using AspectJ to Dependency Inject Domain Objects with Spring</a> - Spring Framework Core リファレンス</li>
</ul>
<p>だったので、この記述に従って実装してみることにした。</p>
<h1 id="環境">環境</h1>
<ul>
<li>Spring Boot 2.1.5</li>
<li>Java11</li>
<li>Lombok 使用</li>
</ul>
<h1 id="ゴール">ゴール</h1>
<p>次のようなコードを動かしたい。最終的なインジェクションのやり方はともかく、 <code>new MyPojo()</code> で生成したインスタンス(つまり非 Spring コンポーネント)で、Spring コンポーネントである <code>MyComponent</code> を使いたい。</p>
<p><a href="https://github.com/yukihane/hello-java/blob/d7436a7cd8f4d2ef49707c21b488bdadd9e5fac1/spring/aspectj/src/main/java/com/github/yukihane/spring/aspectj/AspectjApplication.java">d7436a7cd8f4d2ef49707c21b488bdadd9e5fac1</a>:</p>
<pre><code>@SpringBootApplication
public class AspectjApplication implements CommandLineRunner {

    public static void main(final String[] args) {
        SpringApplication.run(AspectjApplication.class, args);
    }

    @Override
    public void run(final String... args) throws Exception {
        System.out.println(new MyPojo().getText());
    }

    public static class MyPojo {
        @Autowired
        private MyComponent myComponent;

        @Getter
        @Setter
        private String greetingText = &quot;Hello, &quot;;

        public String getText() {
            return getGreetingText() + myComponent.getName();
        }
    }

    @Component
    public static class MyComponent {
        public String getName() {
            return this.getClass().getSimpleName();
        }
    }
}
</code></pre>
<p>なお、このまま実行すると、 <code>MyPojo</code>クラスの<code>myComponent</code>は <code>null</code> のままなので、NPE が発生する。</p>
<h1 id="作業ログ">作業ログ</h1>
<p>結果のソース:</p>
<ul>
<li><a href="https://github.com/yukihane/hello-java/tree/master/spring/aspectj">https://github.com/yukihane/hello-java/tree/master/spring/aspectj</a></li>
</ul>
<h2 id="enablespringconfigured-configurable-付与"><code>@EnableSpringConfigured</code> <code>@Configurable</code> 付与</h2>
<p>前述 <a href="https://docs.spring.io/spring/docs/5.1.7.RELEASE/spring-framework-reference/core.html#aop-atconfigurable">Spring Framework リファレンス</a>に記載されている通り、アノテーションを付与した。</p>
<p><a href="https://github.com/yukihane/hello-java/commit/494691a12b1ae303f3d51caa08b83ccb85923b9e#diff-59f621b35bac66c30e783ac3af61dc70">494691a12b1ae303f3d51caa08b83ccb85923b9e</a>:</p>
<pre tabindex="0"><code>+@EnableSpringConfigured
 @SpringBootApplication
 public class AspectjApplication implements CommandLineRunner {

@@ -20,6 +23,7 @@ public class AspectjApplication implements CommandLineRunner {
         System.out.println(new MyPojo().getText());
     }

+    @Configurable
     public static class MyPojo {
         @Autowired
         private MyComponent myComponent;
</code></pre><h2 id="依存関係追加">依存関係追加</h2>
<p>同じくリファレンスに記載されている通り <code>pom.xml</code> へ <code>spring-aspects</code> を依存関係に追加した。<br />
<a href="https://github.com/yukihane/hello-java/commit/a0b2455bb5b4e5d0937899de20180a482475a023#diff-59f621b35bac66c30e783ac3af61dc70">a0b2455bb5b4e5d0937899de20180a482475a023</a>:</p>
<pre tabindex="0"><code>+    &lt;dependency&gt;
+      &lt;groupId&gt;org.springframework&lt;/groupId&gt;
+      &lt;artifactId&gt;spring-aspects&lt;/artifactId&gt;
+    &lt;/dependency&gt;
</code></pre><h2 id="aspectj-アノテーションプロセッシング">AspectJ アノテーションプロセッシング</h2>
<p>おそらく上で追加したアノテーションをコンパイル時に何かするのだろう、と探したところ <a href="https://www.mojohaus.org/aspectj-maven-plugin/usage.html">aspectj-maven-plugin</a>というものがあったので usage の通り <code>pom.xml</code> へ追記した。</p>
<p><a href="https://github.com/yukihane/hello-java/commit/fc552678d14a5c01f7ea33b6df09453823456510#diff-59f621b35bac66c30e783ac3af61dc70">fc552678d14a5c01f7ea33b6df09453823456510</a>:</p>
<pre tabindex="0"><code>   &lt;build&gt;
     &lt;plugins&gt;
+      &lt;plugin&gt;
+        &lt;groupId&gt;org.codehaus.mojo&lt;/groupId&gt;
+        &lt;artifactId&gt;aspectj-maven-plugin&lt;/artifactId&gt;
+        &lt;version&gt;1.11&lt;/version&gt;
+        &lt;executions&gt;
+          &lt;execution&gt;
+            &lt;goals&gt;
+              &lt;goal&gt;compile&lt;/goal&gt;       &lt;!-- use this goal to weave all your main classes --&gt;
+              &lt;goal&gt;test-compile&lt;/goal&gt;  &lt;!-- use this goal to weave all your test classes --&gt;
+            &lt;/goals&gt;
+          &lt;/execution&gt;
+        &lt;/executions&gt;
+      &lt;/plugin&gt;
       &lt;plugin&gt;
         &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
         &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;
</code></pre><p>この状態でコンパイルを実行すると次のエラーが発生した:</p>
<pre><code>[ERROR] Failed to execute goal org.codehaus.mojo:aspectj-maven-plugin:1.11:compile (default) on project aspectj: Execution default of goal org.codehaus.mojo:aspectj-maven-plugin:1.11:compile failed: Plugin org.codehaus.mojo:aspectj-maven-plugin:1.11 or one of its dependencies could not be resolved: Could not find artifact com.sun:tools:jar:11.0.2 at specified path /home/yuki/.sdkman/candidates/java/11.0.2-open/../lib/tools.jar
</code></pre>
<h2 id="aspectj-maven-plugin-の-java11-対応">aspectj-maven-plugin の Java11 対応</h2>
<p>当 plugin の GitHub Issues/PR のページを見てみると、Java11 に対して未対応のようだった。<br />
対応した fork version を作成されている方がいたのでこれを用いることとした。</p>
<ul>
<li><a href="https://github.com/mojohaus/aspectj-maven-plugin/pull/45#issuecomment-445393068">Adding support for JDK 11 and fixing integration test #45</a></li>
</ul>
<p>また、AJC(AspectJ Compiler の略か？)にターゲット Java バージョンを明示する必要があったので(デフォルトだと 1.4 だと解釈するようだ)、その対応も行った。</p>
<p><a href="https://github.com/yukihane/hello-java/compare/fc552678d14a5c01f7ea33b6df09453823456510...3f0abe04351bf6094e70eae58fcf31ec5cd19c70">21a76a79d9..3f0abe043</a>:</p>
<pre tabindex="0"><code>   &lt;build&gt;
     &lt;plugins&gt;
       &lt;plugin&gt;
-        &lt;groupId&gt;org.codehaus.mojo&lt;/groupId&gt;
+        &lt;groupId&gt;com.nickwongdev&lt;/groupId&gt;
         &lt;artifactId&gt;aspectj-maven-plugin&lt;/artifactId&gt;
-        &lt;version&gt;1.11&lt;/version&gt;
+        &lt;version&gt;1.12.1&lt;/version&gt;
         &lt;executions&gt;
           &lt;execution&gt;
             &lt;goals&gt;
@@ -61,6 +61,11 @@
             &lt;/goals&gt;
           &lt;/execution&gt;
         &lt;/executions&gt;
+        &lt;configuration&gt;
+          &lt;source&gt;${java.version}&lt;/source&gt;
+          &lt;target&gt;${java.version}&lt;/target&gt;
+          &lt;complianceLevel&gt;${java.version}&lt;/complianceLevel&gt;
+        &lt;/configuration&gt;
       &lt;/plugin&gt;
       &lt;plugin&gt;
         &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
</code></pre><h2 id="lombok-との組み合わせ対応-java-に対する-aspectj-適用スキップ">Lombok との組み合わせ対応: .java に対する AspectJ 適用スキップ</h2>
<p>ここまでの状態でコンパイルを実行すると次のエラーとなる:</p>
<pre tabindex="0"><code>[ERROR] Failed to execute goal com.nickwongdev:aspectj-maven-plugin:1.12.1:compile (default) on project aspectj: AJC compiler errors:
[ERROR] error at return getGreetingText() + myComponent.getName();
[ERROR]        ^^
[ERROR] /home/yuki/Documents/repos/java/hello-java/spring/aspectj/src/main/java/com/github/yukihane/spring/aspectj/AspectjApplication.java:36:0::0 The method getGreetingText() is undefined for the type AspectjApplication.MyPojo
</code></pre><p>ここで指摘されている <code>getGreetingText()</code> メソッドは、Lombok の <code>@Getter</code> アノテーションによって生成されるはずのメソッドだ。 AJC compiler はこれが見えないと言っている。<br />
当然だ。<code>.java</code>上には存在しない。</p>
<p>ググると対策が提示されていた。</p>
<ul>
<li><a href="https://stackoverflow.com/a/52869545/4506703">Lombok and AspectJ - Stack Overflow</a></li>
</ul>
<p>ただしなぜこれで上手く行くのか説明は無いので自分なりの解釈をここに書いておく。</p>
<p>AspectJ が weaving を行い得るタイミングは 3 つあるらしい。このうち今回関係しているのは、コンパイル時の話なので、最初の 2 つだ。<br />
<a href="https://www.eclipse.org/aspectj/doc/released/devguide/ltw.html">Chapter 5. Load-Time Weaving - The AspectJ Development Environment Guide</a>:</p>
<blockquote>
</blockquote>
<ul>
<li>Compile-time weaving is the simplest approach. When you have the source code for an application, ajc will compile from source and produce woven class files as output. The invocation of the weaver is integral to the ajc compilation process. The aspects themselves may be in source or binary form. If the aspects are required for the affected classes to compile, then you must weave at compile-time. Aspects are required, e.g., when they add members to a class and other classes being compiled reference the added members.</li>
<li>Post-compile weaving (also sometimes called binary weaving) is used to weave existing class files and JAR files. As with compile-time weaving, the aspects used for weaving may be in source or binary form, and may themselves be woven by aspects.</li>
<li>Load-time weaving (LTW) is simply binary weaving defered until the point that a class loader loads a class file and defines the class to the JVM. To support this, one or more &ldquo;weaving class loaders&rdquo;, either provided explicitly by the run-time environment or enabled through a &ldquo;weaving agent&rdquo; are required.</li>
</ul>
<p>リンク先 Stack Overflow の回答で行っているのは、compile-time weaving をスキップすることで Lombok が getter を生成する前の<code>.java</code>ファイルを AJC が見ることを回避し、ただしスキップしたが<code>.class</code>に対する post-compile weaving は強制している、ということなのだろう。</p>
<p>差分は長い割に回答リンク先と変わらないので記載省略。<br />
リンク: <a href="https://github.com/yukihane/hello-java/commit/4ca1f64cc4174bb3c41932f6a08b3997779a782a#diff-59f621b35bac66c30e783ac3af61dc70">4ca1f64cc4174bb3c41932f6a08b3997779a782a</a>。</p>
<h2 id="weaving-時の問題対処">weaving 時の問題対処</h2>
<p>さて、AspectJ 適用をコンパイル後に先送りしてしまったのでここからは<code>mvn clean compile</code>でなく<code>mvn clean process-classes</code>を実行する必要がある。<br />
早速実行してみると新しいエラーが出る。</p>
<pre tabindex="0"><code>[ERROR] Failed to execute goal com.nickwongdev:aspectj-maven-plugin:1.12.1:compile (default-compile) on project aspectj: AJC compiler errors:
[ERROR] error can&#39;t determine superclass of missing type org.springframework.transaction.interceptor.TransactionAspectSupport
[ERROR] when batch building BuildConfig[null] #Files=0 AopXmls=#0
[ERROR]  [Xlint:cantFindType]
</code></pre><p>これもググったら回答があった:</p>
<ul>
<li><a href="https://stackoverflow.com/a/7352398/4506703">IDEA 10.5.2 Aspectj compiler - can&rsquo;t determine superclass of missing type org.springframework.transaction.interceptor.TransactionAspectSupport<br />
Ask Question - Stack Overflow</a></li>
</ul>
<p>ただし最も upvoted されている回答は何を言っているのかさっぱり理解できない。</p>
<p>何にせよ今回トランザクションに関わることは行っていないし、所詮は lint のメッセージなので<a href="https://www.mojohaus.org/aspectj-maven-plugin/compile-mojo.html#Xlint">Xlint オプション</a>でエラーレベルを下げて放置することにした。</p>
<p><a href="https://github.com/yukihane/hello-java/commit/62ff366f3755cfd882b15bf6b2b8a4b49807b065#diff-59f621b35bac66c30e783ac3af61dc70">62ff366f3755cfd882b15bf6b2b8a4b49807b065</a>:</p>
<pre tabindex="0"><code>               &lt;weaveDirectories&gt;
                 &lt;weaveDirectory&gt;${project.build.directory}/classes&lt;/weaveDirectory&gt;
               &lt;/weaveDirectories&gt;
+              &lt;Xlint&gt;warning&lt;/Xlint&gt;
             &lt;/configuration&gt;
</code></pre><h2 id="警告メッセージ対応">警告メッセージ対応</h2>
<p>ここまでで <code>mvn clean process-classes</code> は正常終了するようになった。ただし、いくつかの warning が残っているのでそれらを対処した。</p>
<h3 id="couldnt-find-aspectjrtjar-on-classpath">couldn&rsquo;t find aspectjrt.jar on classpath</h3>
<p><code>aspectjrt</code>を依存関係に追加した。</p>
<p><a href="https://github.com/yukihane/hello-java/commit/5311573ab6b8dd45cf921e9d234e9e4fdd51e3a7#diff-59f621b35bac66c30e783ac3af61dc70">5311573ab6b8dd45cf921e9d234e9e4fdd51e3a7</a>:</p>
<pre tabindex="0"><code>       &lt;groupId&gt;org.springframework&lt;/groupId&gt;
       &lt;artifactId&gt;spring-aspects&lt;/artifactId&gt;
     &lt;/dependency&gt;
+    &lt;dependency&gt;
+      &lt;groupId&gt;org.aspectj&lt;/groupId&gt;
+      &lt;artifactId&gt;aspectjrt&lt;/artifactId&gt;
+    &lt;/dependency&gt;

     &lt;dependency&gt;
       &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
</code></pre><h3 id="bad-version-number-found-in-homeyukim2repositoryorgaspectjaspectjrt194aspectjrt-194jar-expected-192-found-194">bad version number found in /home/yuki/.m2/repository/org/aspectj/aspectjrt/1.9.4/aspectjrt-1.9.4.jar expected 1.9.2 found 1.9.4</h3>
<p><code>aspectj-maven-plugin</code> が利用すべきバージョンを明示した。</p>
<p><a href="https://github.com/yukihane/hello-java/commit/e63eb7ce811d4081eded526d1310bcea33532c09#diff-59f621b35bac66c30e783ac3af61dc70">e63eb7ce811d4081eded526d1310bcea33532c09</a>:</p>
<pre tabindex="0"><code>             &lt;/aspectLibrary&gt;
           &lt;/aspectLibraries&gt;
         &lt;/configuration&gt;
+        &lt;dependencies&gt;
+          &lt;dependency&gt;
+            &lt;groupId&gt;org.aspectj&lt;/groupId&gt;
+            &lt;artifactId&gt;aspectjtools&lt;/artifactId&gt;
+            &lt;version&gt;1.9.4&lt;/version&gt;
+          &lt;/dependency&gt;
+        &lt;/dependencies&gt;
       &lt;/plugin&gt;
       &lt;plugin&gt;
         &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
</code></pre><h1 id="実行">実行</h1>
<pre><code>mvn clean spring-boot:run
</code></pre>
<p>で所望の結果が得られた:</p>
<pre><code>Hello, MyComponent
</code></pre>
<p>結果的に、ソースコードは当初の想定通りで、<code>@Autowired</code>にコンポーネントがインジェクションされるような形で扱えた。</p>
<h1 id="おまけ">おまけ</h1>
<h2 id="eclipse-ide-の対応">Eclipse IDE の対応</h2>
<p><code>pom.xml</code> に <code>aspectj-maven-plugin</code>(fork でなくオリジナルの方)を設定すると m2e プラグインだったり AJDT だったり？をインストールしてくれようとするのだが、AJDT のリンクが死んでいるようでインストール全体が失敗する。<br />
<a href="https://www.eclipse.org/aspectj/">AspectJ プロジェクトページ</a>からの AJDT リンクも死んでいる。</p>
<p>結果、Eclipse IDE が実行するコンパイルでは weaving されない(ので別途<code>mvn process-classes</code>を実行する必要がある)。</p>
<h2 id="顧客が本当に欲しかったもの">顧客が本当に欲しかったもの</h2>
<pre tabindex="0"><code>
@Component
public class ApplicationContextProvider implements ApplicationContextAware {

    @NoArgsConstructor(access = AccessLevel.PRIVATE)
    private static class Holder {
        private static final Holder SINGLETON = new Holder();

        private ApplicationContext applicationContext;
    }

    @Override
    public void setApplicationContext(final ApplicationContext applicationContext) throws BeansException {
        Holder.SINGLETON.applicationContext = applicationContext;
    }

    public static ApplicationContext getApplicationContext() {
        return Holder.SINGLETON.applicationContext;
    }
}
</code></pre><p><a href="https://stackoverflow.com/a/33528303/4506703">Spring get current ApplicationContext - Stack Overflow の回答コード</a>を参考にしたんだけど、原文がインナークラス 2 つも使っている意味がわからない。</p>

        </section>
        <div class="post-tags">
          
          
          <nav class="nav tags">
            <ul class="tags">
              
              <li><a href="/tags/spring-boot">spring-boot</a></li>
              
            </ul>
          </nav>
          
          
        </div>
      </div>

      
      
    </div>

    </article>
</main>
<footer>
  <div style="display:flex"></div>
  <div class="footer-info">
    2025  &amp;copy;{year}, All Rights Reserved |  <a
      href="https://github.com/athul/archie">Archie Theme</a> | Built with <a href="https://gohugo.io">Hugo</a>
  </div>
</footer>


      <script async src="https://www.googletagmanager.com/gtag/js?id=G-E9J8FN5B4Q"></script>
      <script>
        var doNotTrack = false;
        if ( false ) {
          var dnt = (navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack);
          var doNotTrack = (dnt == "1" || dnt == "yes");
        }
        if (!doNotTrack) {
          window.dataLayer = window.dataLayer || [];
          function gtag(){dataLayer.push(arguments);}
          gtag('js', new Date());
          gtag('config', 'G-E9J8FN5B4Q');
        }
      </script>

</div>
    </body>
</html>
